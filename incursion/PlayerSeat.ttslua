local class = require("incursion.lib.30log.class")
local CommandPointZone = require("incursion.player_seat.CommandPointZone")
local HiddenZone = require("incursion.tts_api.util.HiddenZone")
local Math = require("incursion.util.Math")
local PlayerColor = require("incursion.tts_api.extension.PlayerColor")
local Object = require("incursion.tts_api.extension.Object")


local PlayerSeat = class("PlayerSeat")

PlayerSeat.OCCUPIED_HAND_ZONE_X_POSITION = 20.12
PlayerSeat.INCREMENTAL_HEIGHT_INCREASE_FOR_CARDS_IN_HAND = 0.10

-- We have to shrink the vacant hand zones, otherwise the Allied player's hand zone
-- overlaps with the default player color (white).
PlayerSeat.VACANT_HAND_ZONE_X_SCALE = 5.00
PlayerSeat.OCCUPIED_HAND_ZONE_X_SCALE = 14.07

-- At any time, there are N other states a bid chip can be switched to.
PlayerSeat.NUMBER_OF_BID_CHIP_STATES = 9

function PlayerSeat:init(args)
    self.Factions = args.Factions
    self.HiddenZone = args.HiddenZone
    self.ScriptingZoneGuids = args.ScriptingZoneGuids
    self.CommandPointZone = CommandPointZone(args.CommandPointZone)
    self.BattleCardHand = args.BattleCardHand
    self.BidChip = args.BidChip
    self.FactionReferenceSheet = args.FactionReferenceSheet
    self.Avatar = args.Avatar

    self.FactionsHashSet = {}
    for _,faction in ipairs(self.Factions) do
        self.FactionsHashSet[faction] = _
    end

    self.State = {
        ActiveFactionReferenceSheetGuid = '',
        ActiveAvatarGuid = '',
    }
end

function PlayerSeat:onLoad(savedData)
    if savedData ~= nil then
        self.State = savedData
    end
end

function PlayerSeat:onSave()
    return self.State
end

function PlayerSeat:setupEverything(faction)
    if self.FactionsHashSet[faction] == nil then
        error("The provided faction <" .. tostring(faction) .. "> doesn't sit at this seat <" .. tostring(self) .. ">.")
    end

    local activeFaction = self:getActiveFaction()
    if activeFaction == faction then
        return
    end

    self:_clearSeatFor(activeFaction)

    self:_moveHandZone(faction, self.OCCUPIED_HAND_ZONE_X_POSITION, self.OCCUPIED_HAND_ZONE_X_SCALE)
    HiddenZone.changeColor(faction.PlayerColor.Name, self.HiddenZone.Guid)
    self:_placeBidChips(faction)
    self:_placeFactionReferenceSheet(faction)
    self:_placeAvatar(faction)
end

function PlayerSeat:_clearSeatFor(activeFaction)
    if activeFaction == nil then
        return
    end

    self:_moveHandZone(activeFaction, activeFaction.VacantHandZonePositionX, self.VACANT_HAND_ZONE_X_SCALE)

    -- Delete previously placed items, like Bid Chips and Faction Reference Sheet:
    Object.tryDestroy(getObjectFromGUID(self.State.ActiveFactionReferenceSheetGuid))
    Object.tryDestroy(getObjectFromGUID(self.State.ActiveAvatarGuid))
    self:_deleteBidChips()
end

--[[
This is a hack for deleting the bid chips.
We are deleting any multi-state object with exactly N states (N = "NUMBER_OF_BID_CHIP_STATES").

The ideal solution would store the Bid Chip GUIDs in self.State, like we do for the Faction Reference Sheet.
However, this doesn't work for multi-state objects because each state has a different GUID.
]]
function PlayerSeat:_deleteBidChips()
    local scriptingZone = getObjectFromGUID(self.HiddenZone.ScriptingZoneGuid)
    for _,obj in ipairs(scriptingZone.getObjects()) do
        local states = obj.getStates()
        local numStates = #states
        if numStates == self.NUMBER_OF_BID_CHIP_STATES then
            destroyObject(obj)
        end
    end
end

function PlayerSeat:_moveHandZone(faction, handZoneXPosition, handZoneXScale)
    -- Only shift the X position. The rest of the transform is constant.
    local color = Player[faction.PlayerColor.Name]
    local handTransform = color.getHandTransform()
    handTransform.position.x = handZoneXPosition
    handTransform.scale.x = handZoneXScale
    color.setHandTransform(handTransform)
end

function PlayerSeat:_placeBidChips(faction)
    -- Place in order 0 through 5. Chips are a multi-state object.
    for index,position in ipairs(self.BidChip.Positions) do
        local objectStateId = index - 1
        if index == 1 then objectStateId = 10 end -- Chip 0 is state 10

        self:_placeBidChip(faction, position, objectStateId)
    end
end

function PlayerSeat:_placeBidChip(faction, position, objectStateId)
    local infiniteBag = getObjectFromGUID(faction.InfiniteBagGuids.BidChip)

    local function setState(bidChip)
        Object.setState(bidChip, objectStateId)
    end

    infiniteBag.takeObject({
        position          = position,
        rotation          = self.BidChip.Rotation,
        smooth            = false,
        index             = 1,
        callback_function = setState,
    })
end

function PlayerSeat:_placeFactionReferenceSheet(faction)
    local infiniteBag = getObjectFromGUID(faction.InfiniteBagGuids.FactionReferenceSheet)

    infiniteBag.takeObject({
        position          = self.FactionReferenceSheet.Position,
        rotation          = self.FactionReferenceSheet.Rotation,
        smooth            = false,
        index             = 1,
        callback_function = function(obj) self.State.ActiveFactionReferenceSheetGuid = obj.getGUID() end,
    })
end

function PlayerSeat:_placeAvatar(faction)
    local infiniteBag = getObjectFromGUID(faction.Avatar.InfiniteBagGuid)

    local rotation = Vector(faction.Avatar.Rotation):add(Vector(0, self.Avatar.ExtraRotationDegrees, 0))
    local position = Vector(faction.Avatar.Position):scale(Vector(1, 1, self.Avatar.DepthMultiplier))

    local callback = function(obj)
        obj.setLock(true)
        obj.interactable = false
        -- HACK: Wait 1 frame before capturing GUID because otherwise it will be duplicate w/ the other Drop Trooper player.
        Wait.frames(function() self.State.ActiveAvatarGuid = obj.getGUID() end, 1)
    end

    infiniteBag.takeObject({
        position          = position,
        rotation          = rotation,
        smooth            = false,
        index             = 1,
        callback_function = callback,
    })
end

--[[
Return the faction which was most recently set up, or nil if no faction has been setup.

Note: we could save the faction into a class variable inside setupEverything(),
but then we'd need to deal with saving state:
https://api.tabletopsimulator.com/event/#onsave
]]
function PlayerSeat:getActiveFaction()
    for _,faction in ipairs(self.Factions) do
        local color = faction.PlayerColor.Name
        local handTransform = Player[color].getHandTransform()

        if Math.floatEquals(handTransform.position.x, self.OCCUPIED_HAND_ZONE_X_POSITION) then
            return faction
        end
    end

    return nil
end

--[[
Deal cards to seated player through TTS API, or deal manually if color is not seated.
]]
function PlayerSeat:dealCards(numCards, deckGuid)
    local deck = getObjectFromGUID(deckGuid)
    local activeFaction = self:getActiveFaction()
    if activeFaction ~= nil and Player[activeFaction.PlayerColor.Name].seated then
        deck.deal(numCards, activeFaction.PlayerColor.Name)
    else
        self:_manuallyDealCards(numCards, deck)
    end
end

function PlayerSeat:_manuallyDealCards(numCards, deckObj)
    if numCards == 0 then
        return
    elseif numCards < 0 then
        error("numCards cannot be negative; receieved value: "..tostring(numCards))
    end

    local hand = self.BattleCardHand
    local totalWidth = hand.TotalWidth
    local cardWidth = hand.CardWidth
    local centerTransform = Vector(hand.CenterTransform)
    local leftToRight = Vector(hand.LeftToRight)

    local allottedCardWidth = math.min(cardWidth, totalWidth/(numCards))
    local leftOffset = (numCards-1)/2 * allottedCardWidth
    local leftmostTransform = centerTransform - leftToRight:normalized() * leftOffset

    for cardNum=1,numCards do
        local transform = leftmostTransform + leftToRight:normalized() * (cardNum - 1) * allottedCardWidth
        local up = Vector(0.0, 1.0, 0.0)
        local height = self.INCREMENTAL_HEIGHT_INCREASE_FOR_CARDS_IN_HAND*cardNum
        transform:add(up * height)
        deckObj.takeObject({
            position          = transform,
            rotation          = hand.CardRotation,
            smooth            = true,
            index             = 0,
        })
    end
end

function PlayerSeat.__tostring(this)
    local factionsStr = ""
    for _,faction in ipairs(this.Factions) do
        factionsStr = factionsStr .. tostring(faction) .. ","
    end
    factionsStr = factionsStr:sub(1, -2) -- remove trailing comma

    return string.format("PlayerSeat({Factions=%s})", tostring(factionsStr))
end

return PlayerSeat
